import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.multioutput import MultiOutputClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import classification_report, confusion_matrix

# ---------- LOAD DATA ----------
df = pd.read_csv('single_attribute.csv')

# ---------- FEATURES ----------
audio_features = [
    'zcr', 'rms', 'centroid', 'bw', 'rolloff', 'contrast', 'tonnetz',
    'chroma', 'mfcc_1', 'mfcc_2', 'mfcc_3', 'mfcc_4',
    'mfcc_5', 'mfcc_6', 'mfcc_7', 'mfcc_8', 'mfcc_9', 'mfcc_10',
    'mfcc_11', 'mfcc_12', 'mfcc_13', 'duration'
]

# ---------- TARGETS ----------
label_targets = ['diagnosis', 'cough_type', 'severity', 'quality']  # extend to match your file!

label_encoders = {}

# ----- MAKE LABELS SAFE AS STRINGS, NO NANS OR FLOATS -----
for target in label_targets:
    df[target] = df[target].apply(
        lambda x: str(x) if pd.notnull(x) and str(x).strip() not in ["", "nan", "None"] else "unknown"
    )
    le = LabelEncoder()
    df[target + '_enc'] = le.fit_transform(df[target])
    label_encoders[target] = le

X = df[audio_features]
Y = df[[target + '_enc' for target in label_targets]]

# ---------- SPLIT ----------
X_train, X_test, Y_train, Y_test = train_test_split(
    X, Y, test_size=0.2, random_state=42
)

# ---------- MULTILABEL MODEL ----------
rf = RandomForestClassifier(n_estimators=100, random_state=42)
clf = MultiOutputClassifier(rf)
clf.fit(X_train, Y_train)

Y_pred = clf.predict(X_test)

# ---------- RESULTS FOR EACH LABEL ----------
for idx, target in enumerate(label_targets):
    print(f"\n====== RESULTS: {target.upper()} =======")
    y_true = Y_test.iloc[:, idx]
    y_pred = Y_pred[:, idx]
    le = label_encoders[target]
    # Avoid TypeError for float labels
    target_names = [str(c) for c in le.classes_]
    print(classification_report(y_true, y_pred, target_names=target_names, zero_division=0))
    print("Confusion Matrix:\n", confusion_matrix(y_true, y_pred))

# ---------- FEATURE IMPORTANCE FOR FIRST LABEL ----------
importances = rf.feature_importances_
print("\nTop Features (by avg importance):")
for name, imp in sorted(zip(audio_features, importances), key=lambda x: -x[1]):
    print(f"{name}: {imp:.4f}")

# ---------- EXAMPLE: Predict on New Audio Sample ----------
# Example usage for predicting on a new audio sample.
# new_sample = [feature1, feature2, ..., featureN]  # Replace with real feature values!
# Y_pred_new = clf.predict([new_sample])
# decoded_labels = {target: label_encoders[target].inverse_transform([Y_pred_new[0][i]])[0]
#                   for i, target in enumerate(label_targets)}
# print("Predicted labels:", decoded_labels)
